# DP
# 계단 수 : 45656처럼 인접한 모든 자리의 수 차이가 1
# N길이의 수 중에 0~9까지 모든 수가 있는 계단 수의 개수 출력
# N: 10 -> 9876543210
# N: 11 -> 98765432101, 10123456789, 89876543210
# N: 12 -> 210123456789, 987654321012,
# N: 12 -> 9876543210을 base로 987654321210,987654321010 이렇게 맨끝에 수넣는게 2가지 가능
# 987654321010, 987654321012도 가능 2개씩 가능? ok, N이 12이면 사이에 2개씩 넣을 수 있음
# 결론적으로 N:12 이면 11*2*2-1개가 가능(0123456789가 베이스인경우때문에 *2)(??맞냐? 다시생각)
# 감소하는수 N:10 -> 9876543210 에서 리스트를 만들고 사이사이에 넣는방식으로 N개수 맞추는 방식
# 맨끝이 0이면 result += 1, 맨끝이 0이아니면 += 2


#N은 하나만 주어진다.
#bit-masking 사용
N = int(input())
last = 10
bit = 1<<10

#dp[N][last][bit], N<=100 인 자연수, last는 마지막수(0~9), bit는 비트마스킹 1023인 수만 출력하면댐
dp = [[[0 for i in range(bit)] for i in range(last)] for i in range(N+1)]

for i in range(1,10):
    dp[1][i][1<<i] = 1

for i in range(2,N+1):
    for j in range(10):
        for k in range(bit):
            mask = k | (1<<j)
            tmp1 = 0
            tmp2 = 0
            if j>0 :
                tmp1 = dp[i-1][j-1][k]
            if j<9 :
                tmp2 = dp[i-1][j+1][k]
            dp[i][j][mask] = (dp[i][j][mask] + tmp1 + tmp2) % 1000000000

sum = 0
for i in range(10):
    sum = (sum + dp[N][i][1023]) % 1000000000

print(sum)
